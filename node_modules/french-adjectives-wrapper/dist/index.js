"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.agreeAdjective = exports.getAdjectiveInfo = void 0;
const french_contractions_1 = require("french-contractions");
const french_adjectives_1 = require("french-adjectives");
function getAdjectiveInfo(adjective, contractsData) {
    const res = {};
    for (const gender of ['M', 'F']) {
        for (const number of ['S', 'P']) {
            const agreedAdj = french_adjectives_1.agree(adjective, gender, number, null, false, contractsData);
            res[gender + number] = agreedAdj;
            if (french_adjectives_1.getChangeant(agreedAdj)) {
                res[agreedAdj] = french_adjectives_1.getChangeant(agreedAdj);
            }
        }
    }
    return res;
}
exports.getAdjectiveInfo = getAdjectiveInfo;
function tryGetFromAdjectivesInfo(adjectivesInfo, adjective, gender, number, noun, isBeforeNoun, contractsData) {
    if (adjectivesInfo) {
        const key = gender + number;
        if (adjectivesInfo[adjective] && adjectivesInfo[adjective][key]) {
            const agreedAdj = adjectivesInfo[adjective][key];
            if (isBeforeNoun && number === 'S' && adjectivesInfo[adjective][agreedAdj] != null) {
                if (french_contractions_1.contracts(noun, contractsData)) {
                    return adjectivesInfo[adjective][agreedAdj];
                }
            }
            return agreedAdj;
        }
    }
}
function agreeAdjective(adjectivesInfo, adjective, gender, number, noun, isBeforeNoun, contractsData) {
    if (gender != 'M' && gender != 'F') {
        const err = new Error();
        err.name = 'TypeError';
        err.message = `gender must be M or F`;
        throw err;
    }
    if (number != 'S' && number != 'P') {
        const err = new Error();
        err.name = 'TypeError';
        err.message = `number must be S or P`;
        throw err;
    }
    if (isBeforeNoun && !noun) {
        const err = new Error();
        err.name = 'TypeError';
        err.message = `when isBeforeNoun is set, you must provide the noun`;
        throw err;
    }
    const fromAdjectivesInfo = tryGetFromAdjectivesInfo(adjectivesInfo, adjective, gender, number, noun, isBeforeNoun, contractsData);
    if (fromAdjectivesInfo) {
        return fromAdjectivesInfo;
    }
    else {
        return french_adjectives_1.agree(adjective, gender, number, noun, isBeforeNoun, contractsData);
    }
}
exports.agreeAdjective = agreeAdjective;
//# sourceMappingURL=index.js.map
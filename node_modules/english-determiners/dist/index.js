"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.getDet = void 0;
function checkNumberOwned(numberOwned) {
    if (numberOwned != 'S' && numberOwned != 'P') {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `numberOwned must be S or P`;
        throw err;
    }
}
function getDefinite(numberOwned, forceArticlePlural) {
    checkNumberOwned(numberOwned);
    switch (numberOwned) {
        case 'S': {
            return 'the';
        }
        case 'P': {
            if (forceArticlePlural) {
                return 'the';
            }
            else {
                return '';
            }
        }
        // istanbul ignore next
        default:
            return '';
    }
}
function getIndefinite(numberOwned) {
    checkNumberOwned(numberOwned);
    switch (numberOwned) {
        case 'S': {
            return 'a';
        }
        case 'P': {
            return '';
        }
        // istanbul ignore next
        default:
            return '';
    }
}
function getDemonstrative(numberOwned, dist) {
    checkNumberOwned(numberOwned);
    if (!dist) {
        dist = 'NEAR';
    }
    else if (dist != 'NEAR' && dist != 'FAR') {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `dist must be NEAR or FAR, here ${dist}`;
        throw err;
    }
    switch (numberOwned) {
        case 'S': {
            switch (dist) {
                case 'NEAR': {
                    return 'this';
                }
                case 'FAR': {
                    return 'that';
                }
                // istanbul ignore next
                default:
                    return '';
            }
        }
        case 'P': {
            switch (dist) {
                case 'NEAR': {
                    return 'these';
                }
                case 'FAR': {
                    return 'those';
                }
                // istanbul ignore next
                default:
                    return '';
            }
        }
        // istanbul ignore next
        default:
            return '';
    }
}
function getPossessive(genderOwner, numberOwner) {
    if (numberOwner != 'P' && genderOwner != 'M' && genderOwner != 'F' && genderOwner != 'N') {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `genderOwner must be F M or N when POSSESSIVE (unless numberOwner is P)`;
        throw err;
    }
    if (numberOwner != 'S' && numberOwner != 'P') {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `numberOwner must be S or P when POSSESSIVE`;
        throw err;
    }
    switch (numberOwner) {
        case 'S': {
            switch (genderOwner) {
                case 'M':
                    return 'his';
                case 'F':
                    return 'her';
                case 'N':
                    return 'its';
                // istanbul ignore next
                default:
                    return '';
            }
        }
        case 'P': {
            return 'their';
        }
        // istanbul ignore next
        default:
            return '';
    }
}
function getDet(detType, genderOwner, numberOwner, numberOwned, dist, forceArticlePlural) {
    switch (detType) {
        case 'DEFINITE':
            return getDefinite(numberOwned, forceArticlePlural);
        case 'INDEFINITE':
            return getIndefinite(numberOwned);
        case 'DEMONSTRATIVE':
            return getDemonstrative(numberOwned, dist);
        case 'POSSESSIVE':
            return getPossessive(genderOwner, numberOwner);
        default: {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `${detType} is not a supported determiner`;
            throw err;
        }
    }
}
exports.getDet = getDet;
//# sourceMappingURL=index.js.map
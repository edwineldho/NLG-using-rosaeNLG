"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.AsmManager = void 0;
var positions;
(function (positions) {
    positions[positions["BEGIN"] = 0] = "BEGIN";
    positions[positions["END"] = 1] = "END";
    positions[positions["SEP"] = 2] = "SEP";
    positions[positions["OTHER"] = 3] = "OTHER";
})(positions || (positions = {}));
class AsmManager {
    constructor(saveRollbackManager, randomManager, valueManager, helper) {
        this.saveRollbackManager = saveRollbackManager;
        this.randomManager = randomManager;
        this.valueManager = valueManager;
        this.helper = helper;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    //-------------- HELPERS, COMMON
    /*
      array of elements to list
      mixin to call for each elt
      asm
      params just pass through
    */
    runMixinOrValue(mixinFct, elt, params) {
        if (mixinFct) {
            mixinFct(elt, params);
        }
        else {
            this.valueManager.value(elt, params);
        }
    }
    foreach(elts, mixinFct, asm, params) {
        // check assembly
        if (!asm ||
            asm.assembly != null ||
            !asm.mode ||
            ['single_sentence', 'sentences', 'paragraphs', 'list', 'combined'].indexOf(asm.mode) > -1) {
            // ok
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `asm mode is not valid: ${asm.mode}`;
            throw err;
        }
        const nonEmptyElts = [];
        // 0..length sequence
        const eltsToTest = Array.from(Array(elts.length).keys());
        // we have to mix BEFORE testing
        if (asm && asm.mix) {
            this.mix(eltsToTest);
        }
        // start
        this.saveRollbackManager.saveSituation('isEmpty');
        for (const eltToTest of eltsToTest) {
            const elt = elts[eltToTest];
            if (!this.mixinIsEmpty(mixinFct, elt, params)) {
                nonEmptyElts.push(elt);
            }
        }
        this.saveRollbackManager.rollback();
        // get the real asm if dynamic
        let finalAsm = asm;
        if (asm && asm.assembly != null) {
            finalAsm = asm.assembly(nonEmptyElts.length, nonEmptyElts);
        }
        this.listStuff(mixinFct, nonEmptyElts, finalAsm, params);
    }
    /*
      size: to generate a sequence
    */
    assemble(which, asm, size, params) {
        // 0..length sequence
        const eltsToList = Array.from(Array(size).keys());
        this.foreach(eltsToList, which, asm, params);
    }
    mixinIsEmpty(mixinFct, param1, params) {
        const htmlBefore = this.spy.getPugHtml();
        this.runMixinOrValue(mixinFct, param1, params);
        return this.helper.htmlHasNotChanged(htmlBefore);
    }
    listStuffCombined(which, nonEmpty, asm, params) {
        // check asm params
        if (!asm.asms || asm.asms.length !== 2) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `when mode is 'combined', 'asms' array must be provided and have 2 elements`;
            throw err;
        }
        const lastAsm = asm.asms[1];
        const max = lastAsm.max;
        if (!max) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `in 'asms', second asm must have a 'max' property: ${lastAsm}`;
            throw err;
        }
        // do the job
        const firstAsm = asm.asms[0];
        const newNonEmpty = Array.from(Array(Math.ceil(nonEmpty.length / max)).keys());
        this.listStuff((pos, listInfo) => {
            this.listStuff(which, nonEmpty.slice(pos * max, (pos + 1) * max), lastAsm, listInfo);
        }, newNonEmpty, firstAsm, params);
    }
    listStuff(which, nonEmpty, asm, params) {
        // call one or the other
        if (asm && (asm.mode === 'sentences' || asm.mode === 'paragraphs' || asm.mode === 'list')) {
            this.listStuffSentences(which, nonEmpty, asm, params);
        }
        else if (asm && asm.mode === 'combined') {
            this.listStuffCombined(which, nonEmpty, asm, params);
        }
        else {
            // 'single_sentence' is the default value
            this.listStuffSingleSentence(which, nonEmpty, asm, params);
        }
    }
    isMixin(name) {
        if (typeof name === 'string' || name instanceof String) {
            return false;
        }
        else {
            // is 'function'
            return true;
        }
    }
    outputStringOrMixinHelper(name, params) {
        if (this.isMixin(name)) {
            name(params);
        }
        else {
            this.helper.insertValEscaped(name);
        }
    }
    outputStringOrMixin(name, position, params) {
        /*
          should add spaces BEFORE AND AFTER if not present:
            last_separator
            separator
          should add a space AFTER if not present:
            begin_with_general
            begin_with_1
          should add space BEFORE if not present:
            end
        */
        switch (position) {
            case positions.BEGIN: {
                this.outputStringOrMixinHelper(name, params);
                this.helper.insertSeparatingSpaceIfRequired();
                break;
            }
            case positions.END: {
                this.helper.insertSeparatingSpaceIfRequired();
                this.outputStringOrMixinHelper(name, params);
                break;
            }
            case positions.SEP: {
                this.helper.insertSeparatingSpaceIfRequired();
                this.outputStringOrMixinHelper(name, params);
                this.helper.insertSeparatingSpaceIfRequired();
                break;
            }
            case positions.OTHER: {
                this.outputStringOrMixinHelper(name, params);
                break;
            }
        }
    }
    //-------------- MULTIPLE SENTENCES
    isDot(str) {
        return str.trim() === '.';
    }
    getBeginWithElement(param, index) {
        if (!param) {
            return null;
        }
        else if (typeof param === 'string' || param instanceof String || typeof param === 'function') {
            // if it is a string: we take it, but only once
            // if it is a mixin: we take it each time
            if (index === 0 || this.isMixin(param)) {
                return param;
            }
            else {
                return null;
            }
        }
        else if (param instanceof Array) {
            if (index < param.length) {
                return param[index];
            }
            else {
                return null;
            }
        }
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `invalid begin_with_general: ${JSON.stringify(param)}`;
        throw err;
    }
    listStuffSentencesHelper(beginWith, params, elt, which, asm, index, size) {
        if (beginWith != null) {
            this.outputStringOrMixin(beginWith, positions.BEGIN, params);
        }
        this.runMixinOrValue(which, elt, params);
        this.insertSeparatorSentences(asm, index, size, params);
        //- could set pTriggered to true but no read afterwards
    }
    insertSeparatorSentences(asm, index, size, params) {
        //- at the end, after the last output
        switch (index + 1) {
            case size: {
                if (asm.separator) {
                    //- we try to avoid </p>. in the output
                    if (!this.isMixin(asm.separator) && !this.isDot(asm.separator)) {
                        this.outputStringOrMixin(asm.separator, positions.END, params);
                    }
                    else {
                        // pug_mixins.flushBuffer(); <= was this really useful?
                        // if (!/<\/p>(\\s¤)*$/.test(this.spy.getPugHtml())) {
                        // if (!this.spy.getPugHtml().endsWith('</p>')) {
                        //-| #{'|'+getBufferLastChars(4)+'|'}
                        this.outputStringOrMixin(asm.separator, positions.OTHER, params);
                        // }
                    }
                }
                break;
            }
            case size - 1: {
                if (asm.last_separator) {
                    this.outputStringOrMixin(asm.last_separator, positions.SEP, params);
                }
                else if (asm.separator) {
                    this.outputStringOrMixin(asm.separator, positions.SEP, params);
                }
                break;
            }
            default: {
                if (asm.separator) {
                    this.outputStringOrMixin(asm.separator, positions.SEP, params);
                }
                break;
            }
        }
    }
    getBeginningOfElement(asm, size, index) {
        // NB asm cannot be null here as explicitely sentence or paragraph mode
        if (index === 0) {
            if (asm.begin_with_1 != null && size === 1) {
                return asm.begin_with_1;
            }
            else if (asm.begin_with_general != null) {
                return this.getBeginWithElement(asm.begin_with_general, 0);
            }
        }
        else if (index === size - 2) {
            if (asm.begin_last_1) {
                return asm.begin_last_1;
            }
            else {
                return this.getBeginWithElement(asm.begin_with_general, index);
            }
        }
        else if (index === size - 1) {
            if (asm.begin_last != null) {
                return asm.begin_last;
            }
            else {
                return this.getBeginWithElement(asm.begin_with_general, index);
            }
        }
        else {
            return this.getBeginWithElement(asm.begin_with_general, index);
        }
    }
    getListType(asm) {
        return asm.list_type || 'ul';
    }
    getListHtmlSuffix(asm) {
        return asm.list_capitalize ? 'block' : 'inline';
    }
    listPutStart(asm) {
        if (asm.list_intro != null) {
            this.outputStringOrMixin(asm.list_intro, positions.OTHER, null);
        }
        this.helper.insertValUnescaped(`<${this.getListType(asm)}_${this.getListHtmlSuffix(asm)}>`);
    }
    listPutEnd(asm) {
        this.helper.insertValUnescaped(`</${this.getListType(asm)}>`);
    }
    listStuffSentences(which, nonEmpty, asm, params) {
        if (asm.mode === 'paragraphs' && asm.end != null && !this.isMixin(asm.end) && this.isDot(asm.end)) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `when assemble mode is paragraph, the end is ignored when it is a dot.`;
            throw err;
        }
        const size = nonEmpty.length;
        if (!params) {
            params = {};
        }
        // make it available in params
        params.nonEmpty = nonEmpty;
        if (size === 0 && asm && asm.if_empty != null) {
            this.outputStringOrMixin(asm.if_empty, positions.OTHER, params);
        }
        if (asm.mode === 'list' && size !== 0) {
            this.listPutStart(asm);
        }
        for (let index = 0; index < size; index++) {
            // begin
            const beginWith = this.getBeginningOfElement(asm, size, index);
            //- the actual content
            switch (asm.mode) {
                case 'paragraphs': {
                    this.helper.insertValUnescaped('<p>');
                    this.listStuffSentencesHelper(beginWith, params, nonEmpty[index], which, asm, index, size);
                    this.helper.insertValUnescaped('</p>');
                    break;
                }
                case 'sentences': {
                    this.helper.insertSeparatingSpaceIfRequired();
                    this.listStuffSentencesHelper(beginWith, params, nonEmpty[index], which, asm, index, size);
                    this.helper.insertSeparatingSpaceIfRequired();
                    break;
                }
                case 'list': {
                    this.helper.insertValUnescaped(`<li_${this.getListHtmlSuffix(asm)}>`);
                    this.listStuffSentencesHelper(beginWith, params, nonEmpty[index], which, asm, index, size);
                    if (asm.list_end_item != null) {
                        this.outputStringOrMixin(asm.list_end_item, positions.END, null);
                    }
                    this.helper.insertValUnescaped(`</li_${this.getListHtmlSuffix(asm)}>`);
                    break;
                }
            }
        }
        if (asm.mode === 'list' && size !== 0) {
            this.listPutEnd(asm);
        }
    }
    //-------------- SINGLE SENTENCE
    insertSeparatorSingleSentence(asm, index, size, params) {
        if (asm) {
            //- last separator
            if (index + 1 === size - 1) {
                if (asm.last_separator) {
                    this.outputStringOrMixin(asm.last_separator, positions.SEP, params);
                }
                else if (asm.separator) {
                    this.outputStringOrMixin(asm.separator, positions.SEP, params);
                }
                //- normal one
            }
            else if (index + 1 < size - 1 && asm.separator) {
                this.outputStringOrMixin(asm.separator, positions.SEP, params);
            }
        }
    }
    singleSentenceGetBeginning(asm, size) {
        if (asm) {
            if (asm.begin_with_1 != null && size === 1) {
                return asm.begin_with_1;
            }
            else if (asm.begin_with_general != null) {
                return asm.begin_with_general;
            }
        }
        else {
            return null;
        }
    }
    listStuffSingleSentence(which, nonEmpty, asm, params) {
        const size = nonEmpty.length;
        if (!params) {
            params = {};
        }
        // make it available in params
        params.nonEmpty = nonEmpty;
        if (size === 0 && asm && asm.if_empty != null) {
            this.outputStringOrMixin(asm.if_empty, positions.OTHER, params);
        }
        for (let index = 0; index < size; index++) {
            //- begin
            if (index === 0) {
                const beginWith = this.singleSentenceGetBeginning(asm, size);
                if (beginWith != null) {
                    this.outputStringOrMixin(beginWith, positions.BEGIN, params);
                }
            }
            //- the actual content
            this.helper.insertSeparatingSpaceIfRequired();
            this.runMixinOrValue(which, nonEmpty[index], params);
            this.helper.insertSeparatingSpaceIfRequired();
            this.insertSeparatorSingleSentence(asm, index, size, params);
            //-end
            if (index === size - 1) {
                if (asm && asm.end != null) {
                    this.outputStringOrMixin(asm.end, positions.END, params);
                }
            }
        }
    }
    /**
     * Mixes array in place. ES6 version
     * @param {Array} a items An array containing the items.
     * I do not use the shuffle included in random-js because I need to use my own getNextRnd function
     */
    mix(a) {
        for (let i = a.length - 1; i > 0; i--) {
            const j = Math.floor(this.randomManager.getNextRnd() * (i + 1));
            [a[i], a[j]] = [a[j], a[i]];
        }
    }
}
exports.AsmManager = AsmManager;
//# sourceMappingURL=AsmManager.js.map
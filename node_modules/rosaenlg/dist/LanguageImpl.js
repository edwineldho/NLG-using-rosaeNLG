"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageImpl = void 0;
const numeral_1 = __importDefault(require("numeral"));
const date_fns_1 = require("date-fns");
class LanguageImpl {
    constructor(languageCommon) {
        this.defaultDateFormat = 'yyyy-MM-dd';
        this.languageCommon = languageCommon;
    }
    setValueManager(valueManager) {
        this.valueManager = valueManager;
    }
    // shortcut
    getDictManager() {
        return this.languageCommon.dictManager;
    }
    getLanguageCommon() {
        return this.languageCommon;
    }
    getDefaultLastSeparatorForAdjectives() {
        if (!this.defaultLastSeparatorForAdjectives) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `no default last separator for ${this.iso2} language`;
            throw err;
        }
        else {
            return this.defaultLastSeparatorForAdjectives;
        }
    }
    getDet(_det, _params) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `determiners not available in ${this.iso2}`;
        throw err;
    }
    /* istanbul ignore next */
    getAgreeAdj(_adjective, _gender, _number, _subject, _params) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `adjectives not available in ${this.iso2}`;
        throw err;
    }
    getWordGender(_word) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `there is no gender dict for ${this.iso2}, set gender directly`;
        throw err;
    }
    getOrdinal(_val, _gender) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `ORDINAL_TEXTUAL not available in ${this.iso2}`;
        throw err;
    }
    // this is explicitely tied to numeral lib
    getFormatNumberWithNumeral(val, format) {
        if (this.langForNumeral) {
            numeral_1.default.locale(this.langForNumeral);
            return numeral_1.default(val).format(format);
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `FORMAT not available in ${this.iso2}`;
            throw err;
        }
    }
    // this is just a default implementation using numeral, it can be overriden
    getOrdinalNumber(val, _gender) {
        if (this.langForNumeral) {
            numeral_1.default.locale(this.langForNumeral);
            return numeral_1.default(val).format('o');
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `ORDINAL_NUMBER not available in ${this.iso2}`;
            throw err;
        }
    }
    // default implementation using n2words
    getTextualNumber(val, _gender) {
        if (this.n2wordsLib && this.n2wordsLang) {
            let res = '';
            if (val % 1 === 0) {
                // is int
                res = this.n2wordsLib(val, { lang: this.n2wordsLang });
            }
            else {
                // is float
                const splitVal = (val + '').split('.');
                res =
                    this.n2wordsLib(parseInt(splitVal[0]), { lang: this.n2wordsLang }) +
                        ' ' +
                        this.floatingPointWord +
                        ' ' +
                        this.getTextualNumberFloatPart(splitVal[1]);
            }
            return res;
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `TEXTUAL not available in ${this.iso2}`;
            throw err;
        }
    }
    // very basic default implementation
    getTextualNumberFloatPart(floatPartString) {
        /* istanbul ignore else */
        if (this.table0to9) {
            const resArr = [];
            for (let i = 0; i < floatPartString.length; i++) {
                resArr.push(this.table0to9[Number(floatPartString.charAt(i))]);
            }
            return resArr.join(' ');
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `TEXTUAL with floating point parts not available in ${this.iso2}`;
            throw err;
        }
    }
    // override if necessary
    getStdFormatedNumber(val) {
        if (this.langForNumeral) {
            numeral_1.default.locale(this.langForNumeral);
            return numeral_1.default(val).format('0,0.[000000000000]');
        }
        else {
            // default, not so good
            return val.toString();
        }
    }
    // default implementation using date-fns
    getFormattedDate(date, dateFormat) {
        return date_fns_1.format(date, dateFormat || this.defaultDateFormat, { locale: this.langForDateFns });
    }
    // possessiveAdj currently only in Italian
    getFormattedNominalGroup(possessiveAdj, adjBefore, substantive, adjAfter) {
        if (!possessiveAdj) {
            // not tested in Chinese
            /* istanbul ignore next */
            const sep = this.spacesWhenSeparatingElements ? '¤' : '';
            return adjBefore + sep + substantive + sep + adjAfter;
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `possessive adjective not available in ${this.iso2}`;
            throw err;
        }
    }
    /* istanbul ignore next */
    parseSimplifiedString(_val) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `<...> syntax not implemented in ${this.iso2}`;
        throw err;
    }
    // when reference has to be triggered
    thirdPossessionTriggerRef(_owner, _owned, _params, _spy, _helper, _genderNumberManager) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `thirdPossessionTriggerRef not available in ${this.iso2}`;
        throw err;
    }
    // reference has already been triggered
    thirdPossessionRefTriggered(_owner, _owned, _params, _spy, _genderNumberManager) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `thirdPossessionRefTriggered not available in ${this.iso2}`;
        throw err;
    }
    recipientPossession(_owned, _spy, _refsManager, _helper) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `recipientPossession not implemented in ${this.iso2}`;
        throw err;
    }
    getConjugation(_subject, _verb, _tense, _number, _conjParams, _genderNumberManager, _embeddedVerbs, _verbParts) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `verbs not available in ${this.iso2}`;
        throw err;
    }
    isPlural(_val) {
        const err = new Error();
        err.name = 'InvalidArgumentError';
        err.message = `isPlural not implemented in ${this.iso2}`;
        throw err;
    }
    solveTense(originalTense) {
        if (this.universalMapping && this.universalMapping[originalTense]) {
            return this.universalMapping[originalTense];
        }
        else {
            return originalTense;
        }
    }
}
exports.LanguageImpl = LanguageImpl;
//# sourceMappingURL=LanguageImpl.js.map
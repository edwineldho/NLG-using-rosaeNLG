"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SentenceManager = void 0;
class SentenceManager {
    constructor(languageImpl, verbsManager, valueManager, adjectiveManager, synManager, helper) {
        this.languageImpl = languageImpl;
        this.verbsManager = verbsManager;
        this.valueManager = valueManager;
        this.adjectiveManager = adjectiveManager;
        this.synManager = synManager;
        this.helper = helper;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    verb(subject, verbInfo, params) {
        this.subjectVerb(subject, verbInfo, Object.assign(Object.assign({}, params), { noSubject: true }));
    }
    subjectVerb(subject, verbInfo, params) {
        // might have been done before if we go through subjectVerbAdj
        // but not if we use the mixin directly
        const chosenSubject = this.synManager.synFctHelper(subject);
        if (params && params.invertSubjectVerb) {
            if (!this.languageImpl.supportsInvertSubjectVerb) {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `invertSubjectVerb is only valid for de_DE`;
                throw err;
            }
            if (typeof params.invertSubjectVerb !== 'boolean') {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `invertSubjectVerb must be a boolean`;
                throw err;
            }
        }
        if (params && params.noSubject) {
            this.spy.appendPugHtml(this.verbsManager.getAgreeVerb(chosenSubject, verbInfo, params));
        }
        else {
            if (params && params.invertSubjectVerb) {
                this.spy.appendPugHtml(this.helper.getSeparatingSpace() +
                    this.verbsManager.getAgreeVerb(chosenSubject, verbInfo, params) +
                    this.helper.getSeparatingSpace());
                this.valueManager.value(chosenSubject, params);
            }
            else {
                // warning: value has side effects on chosenSubject, typically number
                // thus we cannot agree the verb before running value
                this.valueManager.value(chosenSubject, params);
                this.spy.appendPugHtml(this.helper.getSeparatingSpace() +
                    this.verbsManager.getAgreeVerb(chosenSubject, verbInfo, params) +
                    this.helper.getSeparatingSpace());
            }
        }
    }
    subjectVerbAdj(subject, verbInfo, adjective, params) {
        const chosenSubject = this.synManager.synFctHelper(subject);
        this.subjectVerb(chosenSubject, verbInfo, params);
        // this already adds spaces
        this.adjectiveManager.agreeAdj(adjective, chosenSubject, params);
    }
}
exports.SentenceManager = SentenceManager;
//# sourceMappingURL=SentenceManager.js.map
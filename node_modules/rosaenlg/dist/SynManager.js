"use strict";
/**
 * @license
 * Copyright 2019 Ludan StoecklÃ©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SynManager = void 0;
class SynManager {
    constructor(randomManager, saveRollbackManager, helper, synManagerParams) {
        this.randomManager = randomManager;
        this.saveRollbackManager = saveRollbackManager;
        this.defaultSynoMode = synManagerParams.defaultSynoMode;
        this.helper = helper;
        this.synoSeq = new Map();
        this.synoTriggered = new Map();
    }
    setSpy(spy) {
        this.spy = spy;
    }
    getSynoSeq() {
        return this.synoSeq;
    }
    setSynoSeq(synoSeq) {
        this.synoSeq = synoSeq;
    }
    getSynoTriggered() {
        return this.synoTriggered;
    }
    setSynoTriggered(synoTriggered) {
        this.synoTriggered = synoTriggered;
    }
    getSynoTriggeredOn(which) {
        return this.synoTriggered.get(which) || [];
    }
    getNextSeqNotIn(whichName, size, exclude) {
        const lastRecorded = this.synoSeq.get(whichName);
        function getNext(last) {
            return last >= size ? 1 : last + 1;
        }
        let logicalNext = getNext(lastRecorded ? lastRecorded : 0);
        while (exclude.indexOf(logicalNext) > -1) {
            logicalNext = getNext(logicalNext);
        }
        return logicalNext;
    }
    synFct(items) {
        if (items.length == 1) {
            return items[0];
        }
        else {
            return items[Math.floor(this.randomManager.getNextRnd() * items.length)];
        }
    }
    synFctHelper(items) {
        if (Array.isArray(items)) {
            // choose one in the array
            return this.synFct(items);
        }
        else {
            return items;
        }
    }
    simpleSyn(items) {
        /*
          DO NOT check this.saveRollbackManager.isEvaluatingEmpty
          synFct MUST be triggered properly to update random numbers properly
        */
        const chosen = this.synFct(items);
        this.helper.insertValEscaped(chosen);
    }
    getToTest(synoMode, which, whichName, size, params, excludeParam) {
        switch (synoMode) {
            case 'sequence':
                return { index: this.getNextSeqNotIn(whichName, size, excludeParam), exclude: excludeParam };
            case 'once': {
                // we try
                const toTest = this.randomManager.randomNotIn(size, params, excludeParam);
                if (toTest) {
                    return { index: toTest, exclude: excludeParam };
                }
                else {
                    // nothing new is found
                    // we set as potentially valid those who were triggered
                    const triggered = this.getSynoTriggeredOn(whichName);
                    const newExclude = excludeParam.filter(function wasNotInTriggered(val) {
                        // true = keep the element; we exclude if it was not triggered
                        return triggered.indexOf(val) == -1;
                    });
                    // and we reset triggered list
                    // we try to avoid the last one that was triggered, when possible
                    const triggeredNext = [];
                    if (triggered.length > 1) {
                        // more than 1 are non empty, so we can avoid
                        const lastToAvoid = triggered[triggered.length - 1];
                        triggeredNext.push(lastToAvoid);
                        newExclude.push(lastToAvoid);
                    }
                    this.synoTriggered.set(whichName, triggeredNext);
                    // and try again
                    return { index: this.randomManager.randomNotIn(size, params, newExclude), exclude: newExclude };
                }
            }
            case 'random':
                return { index: this.randomManager.randomNotIn(size, params, excludeParam), exclude: excludeParam };
        }
    }
    // for some reason which.name does not work properly, thus we have whichName
    runSynz(which, whichName, size, params, excludeParam) {
        const synoMode = params.mode || this.defaultSynoMode;
        if (['sequence', 'random', 'once'].indexOf(synoMode) === -1) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `invalid synonym mode: ${synoMode}`;
            throw err;
        }
        let exclude = excludeParam;
        let toTest;
        // first call
        if (!excludeParam) {
            exclude = [];
            if (synoMode === 'once') {
                const triggered = this.getSynoTriggeredOn(whichName);
                // we try to exclude all the ones that already were triggered
                exclude = exclude.concat(triggered);
            }
            // we force and it has not been excluded so we test it
            if (params.force) {
                toTest = params.force;
            }
        }
        if (toTest == null) {
            const toTestStruct = this.getToTest(synoMode, which, whichName, size, params, exclude);
            toTest = toTestStruct.index;
            exclude = toTestStruct.exclude;
        }
        if (toTest != null) {
            // just stop if nothing new is found
            this.saveRollbackManager.saveSituation('isEmpty');
            const htmlBefore = this.spy.getPugHtml();
            // can throw exception
            which(toTest, params);
            if (this.helper.htmlHasNotChanged(htmlBefore)) {
                exclude.push(toTest);
                this.saveRollbackManager.rollback();
                // continue
                this.runSynz(which, whichName, size, params, exclude);
            }
            else {
                // rollback and do it for real
                this.saveRollbackManager.rollback();
                // add spaces before and after
                this.helper.insertSeparatingSpaceIfRequired();
                which(toTest, params);
                this.helper.insertSeparatingSpaceIfRequired();
                switch (synoMode) {
                    case 'random': {
                        // nothing special
                        break;
                    }
                    case 'sequence': {
                        this.synoSeq.set(whichName, toTest);
                        break;
                    }
                    case 'once': {
                        const triggered = this.synoTriggered.get(whichName) || [];
                        triggered.push(toTest);
                        this.synoTriggered.set(whichName, triggered);
                        break;
                    }
                }
                // and don't continue
            }
        }
    }
}
exports.SynManager = SynManager;
//# sourceMappingURL=SynManager.js.map
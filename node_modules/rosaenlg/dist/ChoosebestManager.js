"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ChoosebestManager = void 0;
const synonym_optimizer_1 = require("synonym-optimizer");
class ChoosebestManager {
    constructor(language, helper, saveRollbackManager, randomManager, defaultAmong) {
        this.language = language;
        this.helper = helper;
        this.saveRollbackManager = saveRollbackManager;
        this.randomManager = randomManager;
        this.defaultAmong = defaultAmong;
        this.synOptimizer = new synonym_optimizer_1.SynOptimizer(language);
    }
    setSpy(spy) {
        this.spy = spy;
    }
    runChoosebest(which, params) {
        if (this.saveRollbackManager.isEvaluatingChoosebest) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `choosebest cannot be imbricated`;
            throw err;
        }
        const debugOn = params && params.debug ? true : false;
        if (debugOn) {
            params.debugRes = {
                maxTest: null,
                perfectScoreAfter: null,
                bestScore: null,
                bestText: null,
                bestDebug: null,
                worstScore: null,
                worstText: null,
                worstDebug: null,
            };
        }
        let maxTest;
        if (params && params.among) {
            maxTest = params.among;
        }
        else {
            maxTest = this.defaultAmong;
        }
        if (debugOn) {
            params.debugRes.maxTest = maxTest;
        }
        function getFromParamsAndStoreDebug(paramName) {
            const res = params && params[paramName] ? params[paramName] : null;
            if (debugOn && res) {
                params.debugRes[paramName] = res;
            }
            return res;
        }
        const stopWordsAdd = getFromParamsAndStoreDebug('stop_words_add');
        const stopWordsRemove = getFromParamsAndStoreDebug('stop_words_remove');
        const stopWordsOverride = getFromParamsAndStoreDebug('stop_words_override');
        const identicals = getFromParamsAndStoreDebug('identicals');
        const newContentStart = this.spy.getPugHtml().length;
        // SIMULATE
        const scores = [];
        let alternatives;
        let debugInfos;
        if (debugOn) {
            alternatives = [];
            debugInfos = [];
        }
        for (let i = 0; i < maxTest; i++) {
            // SAVE
            this.saveRollbackManager.saveSituation('choosebest');
            this.randomManager.incrRnd(i);
            which(params);
            const generated = this.helper.getHtmlWithoutRenderDebug(this.spy.getPugHtml().substring(newContentStart));
            // ROLLBACK
            this.saveRollbackManager.rollback();
            if (debugOn) {
                alternatives.push(generated);
            }
            const debugInfo = {
                filteredAlt: null,
                identicals: null,
                identicalsMap: null,
                wordsWithPos: null,
                score: null,
            };
            const score = this.synOptimizer.scoreAlternative(generated, stopWordsAdd, stopWordsRemove, stopWordsOverride, identicals, debugOn ? debugInfo : null);
            scores.push(score);
            if (debugOn) {
                debugInfos.push(debugInfo);
            }
            // we can stop before if we ever get a perfect score
            if (score === 0) {
                if (debugOn) {
                    params.debugRes.perfectScoreAfter = i;
                }
                break;
            }
        }
        // CHOOSE BEST
        const best = scores.indexOf(Math.min(...scores));
        if (debugOn) {
            params.debugRes.bestScore = scores[best];
            params.debugRes.bestText = alternatives[best];
            params.debugRes.bestDebug = debugInfos[best];
        }
        if (debugOn) {
            const worst = scores.indexOf(Math.max(...scores));
            params.debugRes.worstScore = scores[worst];
            params.debugRes.worstText = alternatives[worst];
            params.debugRes.worstDebug = debugInfos[worst];
        }
        // CHANGE RANDOM POSITION
        this.randomManager.incrRnd(best);
        // AND GENERATE IT
        which(params);
    }
}
exports.ChoosebestManager = ChoosebestManager;
//# sourceMappingURL=ChoosebestManager.js.map
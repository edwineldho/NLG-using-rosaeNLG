"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.SaveRollbackManager = void 0;
class SavePoint {
    constructor(htmlBefore, hasSaid, triggeredRefs, refGenderMap, refNumberMap, rndNextPos, nextRefs, synoSeq, synoTriggered, verbParts, isEvaluatingEmpty, isEvaluatingNextRep, isEvaluatingChoosebest) {
        // here we have to copy
        this.htmlBefore = htmlBefore;
        this.hasSaid = Object.assign({}, hasSaid);
        this.triggeredRefs = new Map(triggeredRefs);
        this.refGenderMap = new Map(refGenderMap);
        this.refNumberMap = new Map(refNumberMap);
        this.rndNextPos = rndNextPos;
        this.nextRefs = new Map(nextRefs);
        this.synoSeq = new Map(synoSeq);
        // deep copy of the values in the array
        this.synoTriggered = new Map();
        for (const key of synoTriggered.keys()) {
            this.synoTriggered.set(key, [...synoTriggered.get(key)]);
        }
        this.verbParts = verbParts.slice(0);
        this.isEvaluatingEmpty = isEvaluatingEmpty;
        this.isEvaluatingNextRep = isEvaluatingNextRep;
        this.isEvaluatingChoosebest = isEvaluatingChoosebest;
    }
}
class SaveRollbackManager {
    constructor() {
        this.isEvaluatingEmpty = false;
        this.isEvaluatingNextRep = false;
        this.isEvaluatingChoosebest = false;
        this.savePoints = [];
    }
    bindObjects(saidManager, refsManager, genderNumberManager, randomManager, synManager, verbsManager) {
        this.saidManager = saidManager;
        this.refsManager = refsManager;
        this.genderNumberManager = genderNumberManager;
        this.randomManager = randomManager;
        this.synManager = synManager;
        this.verbsManager = verbsManager;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    saveSituation(context) {
        // no need to copy the objects here, just give their reference
        const savePoint = new SavePoint(this.spy.getPugHtml(), this.saidManager.getHasSaidMap(), this.refsManager.getTriggeredRefs(), this.genderNumberManager.getRefGenderMap(), this.genderNumberManager.getRefNumberMap(), this.randomManager.getRndNextPos(), this.refsManager.getNextRefs(), this.synManager.getSynoSeq(), this.synManager.getSynoTriggered(), this.verbsManager.getVerbPartsList(), this.isEvaluatingEmpty, this.isEvaluatingNextRep, this.isEvaluatingChoosebest);
        this.savePoints.push(savePoint);
        switch (context) {
            case 'isEmpty': {
                this.isEvaluatingEmpty = true;
                break;
            }
            case 'nextRep': {
                this.isEvaluatingNextRep = true;
                break;
            }
            case 'choosebest': {
                this.isEvaluatingChoosebest = true;
                break;
            }
        }
    }
    rollback() {
        const savePoint = this.savePoints.pop();
        // istanbul ignore next
        if (!savePoint) {
            const err = new Error();
            err.name = 'InternalError';
            err.message = `was asked to rollback, but savePoints list is empty!`;
            throw err;
        }
        // console.log('SAVEPOINT CONTENT: ' + JSON.stringify(savePoint));
        // there's no point in creating new maps here: we just reuse the ones we created before
        this.saidManager.setHasSaidMap(savePoint.hasSaid);
        this.refsManager.setTriggeredRefs(savePoint.triggeredRefs);
        this.genderNumberManager.setRefGenderMap(savePoint.refGenderMap);
        this.genderNumberManager.setRefNumberMap(savePoint.refNumberMap);
        this.randomManager.setRndNextPos(savePoint.rndNextPos);
        this.refsManager.setNextRefs(savePoint.nextRefs);
        this.synManager.setSynoSeq(savePoint.synoSeq);
        this.synManager.setSynoTriggered(savePoint.synoTriggered);
        this.verbsManager.setVerbPartsList(savePoint.verbParts);
        this.isEvaluatingEmpty = savePoint.isEvaluatingEmpty;
        this.isEvaluatingNextRep = savePoint.isEvaluatingNextRep;
        this.isEvaluatingChoosebest = savePoint.isEvaluatingChoosebest;
        this.spy.setPugHtml(savePoint.htmlBefore);
    }
}
exports.SaveRollbackManager = SaveRollbackManager;
//# sourceMappingURL=SaveRollbackManager.js.map
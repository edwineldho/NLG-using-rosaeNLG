"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageEnglish = void 0;
const LanguageImpl_1 = require("./LanguageImpl");
const english_determiners_1 = require("english-determiners");
const english_ordinals_1 = require("english-ordinals");
const plurals_json_1 = __importDefault(require("english-plurals-list/dist/plurals.json"));
const english_plurals_1 = require("english-plurals");
const english_grammar_js_1 = require("../dist/english-grammar.js");
const english_verbs_helper_1 = require("english-verbs-helper");
const verbs_json_1 = __importDefault(require("english-verbs-irregular/dist/verbs.json"));
const gerunds_json_1 = __importDefault(require("english-verbs-gerunds/dist/gerunds.json"));
const locale_1 = require("date-fns/locale");
const n2words_EN_js_1 = __importDefault(require("../../rosaenlg-n2words/dist/n2words_EN.js"));
class LanguageEnglish extends LanguageImpl_1.LanguageImpl {
    constructor(languageCommon) {
        super(languageCommon);
        this.iso2 = 'en';
        this.langForNumeral = 'en';
        this.langForDateFns = locale_1.enUS;
        this.n2wordsLang = 'en';
        this.n2wordsLib = n2words_EN_js_1.default;
        this.floatingPointWord = 'point';
        this.table0to9 = ['zero', 'one', 'two', 'three', 'four', 'five', 'six', 'seven', 'eight', 'nine'];
        this.hasGender = false;
        this.hasNeutral = true;
        this.defaultAdjPos = 'BEFORE';
        this.defaultTense = 'PRESENT';
        this.defaultLastSeparatorForAdjectives = 'and';
        this.universalMapping = {
            UNIVERSAL_PRESENT: 'SIMPLE_PRESENT',
            UNIVERSAL_PAST: 'SIMPLE_PAST',
            UNIVERSAL_FUTURE: 'SIMPLE_FUTURE',
            UNIVERSAL_PERFECT: 'PERFECT_PRESENT',
            UNIVERSAL_PLUPERFECT: 'PERFECT_PAST',
        };
        this.spacesWhenSeparatingElements = true;
        // create English combined resource
        this.mergedVerbsDataEn = english_verbs_helper_1.mergeVerbsData(verbs_json_1.default, gerunds_json_1.default);
    }
    getDet(det, params) {
        return english_determiners_1.getDet(det, params.genderOwner, params.numberOwner || 'S', params.numberOwned || 'S', params.dist, params.useTheWhenPlural);
    }
    getAgreeAdj(adjective /*, gender: Genders, number: Numbers, subject: any, params: AgreeAdjParams*/) {
        // no agreement for adjectives in English
        return adjective;
    }
    getOrdinal(val) {
        return english_ordinals_1.getOrdinal(val);
    }
    getSubstantive(subst, number) {
        if (number === 'S') {
            return subst;
        }
        else {
            return english_plurals_1.getPlural(this.getDictManager().getWordData(), plurals_json_1.default, subst);
        }
    }
    parseSimplifiedString(val) {
        return english_grammar_js_1.parse(val, {
        /* no dict */
        });
    }
    thirdPossessionTriggerRef(owner, owned, params, spy) {
        let possForm;
        if (params && params.possForm) {
            if (params.possForm === 'OF' || params.possForm === 'S') {
                possForm = params.possForm;
            }
            else {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `possForm must be either OF or S`;
                throw err;
            }
        }
        else {
            possForm = 'OF';
        }
        switch (possForm) {
            case 'OF': {
                this.valueManager.value(owned, Object.assign({}, params, { det: 'DEFINITE' }));
                spy.appendPugHtml(` of `);
                this.valueManager.value(owner, Object.assign({}, params));
                break;
            }
            case 'S': {
                this.valueManager.value(owner, Object.assign({}, params));
                spy.appendPugHtml(`'s`);
                this.valueManager.value(owned, Object.assign({}, params));
                break;
            }
        }
    }
    thirdPossessionRefTriggered(owner, owned, params, spy, genderNumberManager) {
        const det = this.getDet('POSSESSIVE', {
            genderOwned: null,
            genderOwner: genderNumberManager.getRefGender(owner, params),
            numberOwner: genderNumberManager.getRefNumber(owner, params),
            numberOwned: null,
            case: null,
            dist: null,
            after: null,
        });
        spy.appendPugHtml(` ${det} ${owned} `);
    }
    recipientPossession(owned, spy) {
        spy.appendPugHtml('your');
        this.valueManager.value(owned, { _OWNER: true });
    }
    getConjugation(_subject, verb, tense, number, conjParams, _genderNumberManager, embeddedVerbs) {
        return english_verbs_helper_1.getConjugation(embeddedVerbs || this.mergedVerbsDataEn, verb, this.solveTense(tense), number, conjParams);
    }
    isPlural(val) {
        if (val === 1 || val === -1) {
            return false;
        }
        else {
            return true;
        }
    }
}
exports.LanguageEnglish = LanguageEnglish;
//# sourceMappingURL=LanguageEnglish.js.map
"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.VerbsManager = void 0;
class VerbsManager {
    constructor(languageImpl, genderNumberManager, synManager, saveRollbackManager, helper) {
        this.languageImpl = languageImpl;
        this.genderNumberManager = genderNumberManager;
        this.synManager = synManager;
        this.saveRollbackManager = saveRollbackManager;
        this.helper = helper;
        this.verbParts = [];
    }
    setSpy(spy) {
        this.spy = spy;
    }
    getVerbPartsList() {
        return this.verbParts;
    }
    setVerbPartsList(verbParts) {
        this.verbParts = verbParts;
    }
    setEmbeddedVerbs(embeddedVerbs) {
        this.embeddedVerbs = embeddedVerbs;
    }
    encapsulateConjParams(conjParams) {
        if (typeof conjParams === 'object' && !Array.isArray(conjParams)) {
            // already in .verb prop
            return conjParams;
        }
        else {
            // direct arg: string or array
            return {
                verb: conjParams,
            };
        }
    }
    getAgreeVerb(subject, conjParamsOriginal, additionalParams) {
        if (this.saveRollbackManager.isEvaluatingEmpty) {
            return 'SOME_VERB';
        }
        else {
            const conjParams = this.encapsulateConjParams(conjParamsOriginal);
            const verbName = this.synManager.synFctHelper(conjParams.verb);
            if (!verbName) {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = `verb needed`;
                throw err;
            }
            const tense = conjParams.tense || this.languageImpl.defaultTense;
            const number = this.genderNumberManager.getRefNumber(subject, additionalParams) || 'S';
            return this.languageImpl.getConjugation(subject, verbName, tense, number, conjParams, this.genderNumberManager, this.embeddedVerbs, this.verbParts);
        }
    }
    popVerbPartInBuffer() {
        if (!this.languageImpl.canPopVerbPart) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `verbPart is not available for ${this.languageImpl.iso2}`;
            throw err;
        }
        const verb = this.verbParts.pop();
        if (!verb) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `verbPart nothing to pop`;
            throw err;
        }
        this.spy.appendPugHtml(this.helper.getSeparatingSpace() + verb + this.helper.getSeparatingSpace());
    }
}
exports.VerbsManager = VerbsManager;
//# sourceMappingURL=VerbsManager.js.map
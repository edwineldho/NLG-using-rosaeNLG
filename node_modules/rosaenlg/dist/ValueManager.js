"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.ValueManager = void 0;
function isSimplifiedString(obj) {
    return typeof obj === 'string' && obj.charAt(0) === '<' && obj.charAt(obj.length - 1) === '>';
}
class ValueManager {
    constructor(languageImpl, refsManager, genderNumberManager, randomManager, adjectiveManager, helper, possessiveManager, synManager, saveRollbackManager, constants) {
        this.languageImpl = languageImpl;
        this.refsManager = refsManager;
        this.genderNumberManager = genderNumberManager;
        this.randomManager = randomManager;
        this.adjectiveManager = adjectiveManager;
        this.helper = helper;
        this.possessiveManager = possessiveManager;
        this.synManager = synManager;
        this.simplifiedStringsCache = new Map();
        this.saveRollbackManager = saveRollbackManager;
        this.constants = constants;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    // once the element in the array is chosen
    valueOfFirstParam(firstParam, params) {
        if (typeof firstParam === 'number') {
            this.spy.appendPugHtml(this.valueNumber(firstParam, params));
        }
        else if (typeof firstParam === 'string') {
            this.spy.appendPugHtml(this.valueString(firstParam, params));
        }
        else if (firstParam instanceof Date) {
            this.spy.appendPugHtml(this.valueDate(firstParam, params ? params.dateFormat : null));
        }
        else if (firstParam.isAnonymous) {
            // do nothing
        }
        else if (typeof firstParam === 'object') {
            // it calls mixins, it already appends
            this.valueObject(firstParam, params);
        }
        else if (typeof firstParam === 'function') {
            // it is supposed to be a mixin, but we can't really check, so we just call it, with the params
            const theMixinFct = firstParam;
            theMixinFct(params);
        }
        else {
            const err = new Error();
            err.name = 'TypeError';
            err.message = `value not possible on: ${JSON.stringify(firstParam)}`;
            throw err;
        }
    }
    value(obj, params) {
        if (typeof obj === 'undefined' || obj === null) {
            // PS: value of empty string is OK
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `first parameter of value is null or undefined`;
            throw err;
        }
        // param is simplified string
        if (isSimplifiedString(obj)) {
            this.valueSimplifiedString(obj.substring(1, obj.length - 1), params);
            return; // don't do the rest, as it will call value again indirectly
        }
        if (params && params.owner) {
            const newParams = Object.assign({}, params);
            newParams.owner = null; // to avoid looping: we already take into account that param
            this.possessiveManager.thirdPossession(params.owner, obj, newParams);
            return;
        }
        // if first param is an array: we choose one
        const firstParam = this.synManager.synFctHelper(obj);
        // makes the real job
        this.valueOfFirstParam(firstParam, params);
        if (params && params.represents) {
            this.genderNumberManager.setRefGender(params.represents, firstParam, params);
            // we cannot use setRefGenderNumber because sometimes obj is a word => dict lookup
            if (params.number) {
                this.genderNumberManager.setRefNumber(params.represents, params.number);
            }
        }
    }
    valueDate(val, dateFormat) {
        if (this.saveRollbackManager.isEvaluatingEmpty) {
            return 'SOME_DATE';
        }
        else {
            // we can't protect all: e.g. "avril" in French must not be protected (d'avril)
            // but we can/must protect everything that has numbers, : or , in it
            const original = this.languageImpl.getFormattedDate(val, dateFormat);
            const regexDe = new RegExp(`[^${this.constants.tousCaracteresMinMajRe}].*`);
            return original.replace(regexDe, '§$&§');
        }
    }
    valueSimplifiedString(val, params) {
        if (this.saveRollbackManager.isEvaluatingEmpty) {
            this.spy.appendPugHtml('SOME_STRING');
            return;
        }
        let solved;
        solved = this.simplifiedStringsCache.get(val);
        if (!solved) {
            try {
                solved = this.languageImpl.parseSimplifiedString(val);
                // manager unknown words
                if (solved.unknownNoun) {
                    if (solved.gender != 'M' && solved.gender != 'F' && solved.gender != 'N') {
                        const err = new Error();
                        err.name = 'NotFoundInDict';
                        err.message = `${solved.noun} is not in dict. Indicate a gender, M F or N!`;
                        throw err;
                    }
                    delete solved['unknownNoun'];
                }
                this.simplifiedStringsCache.set(val, solved);
            }
            catch (e) {
                const err = new Error();
                err.name = 'ParseError';
                err.message = `could not parse <${val}>: ${e.message}`;
                throw err;
            }
        }
        // we keep the params
        const newParams = Object.assign({}, solved, params);
        delete newParams['noun'];
        if (params && params.debug) {
            console.log(`DEBUG: <${val}> => ${JSON.stringify(solved)} - final: ${solved.noun} ${JSON.stringify(newParams)}`);
        }
        this.value(solved.noun, newParams);
    }
    getAdjPos(adjPosParams) {
        let adjPos;
        if (adjPosParams && adjPosParams.adjPos) {
            adjPos = adjPosParams.adjPos;
            if (adjPos && adjPos != 'AFTER' && adjPos != 'BEFORE') {
                const err = new Error();
                err.name = 'InvalidArgumentError';
                err.message = 'adjective position must be either AFTER or BEFORE';
                throw err;
            }
        }
        if (!adjPos) {
            adjPos = this.languageImpl.defaultAdjPos;
        }
        return adjPos;
    }
    getAdjStringFromList(val, params, adjectives, separator, adjPos) {
        if (!adjectives || adjectives.length === 0) {
            return '';
        }
        const agreedAdjs = [];
        for (const adjective of adjectives) {
            agreedAdjs.push(this.adjectiveManager.getAgreeAdj(adjective, val, {
                gender: params.gender,
                genderOwned: params.genderOwned,
                number: params.number,
                numberOwned: params.numberOwned,
                case: params.case,
                det: params.det,
                adjPos: adjPos, // we cannot use the params direct here: possible mix of before and after
            }));
        }
        let lastSep = null;
        if (agreedAdjs.length > 1) {
            let between;
            if (separator != null) {
                between = separator;
            }
            else {
                between = this.languageImpl.getDefaultLastSeparatorForAdjectives();
            }
            lastSep = this.helper.getSeparatingSpace() + between + this.helper.getSeparatingSpace();
        }
        switch (agreedAdjs.length) {
            case 1:
                return agreedAdjs[0];
            case 2:
                return agreedAdjs.join(lastSep);
            default:
                return agreedAdjs.slice(0, agreedAdjs.length - 1).join(', ') + lastSep + agreedAdjs[agreedAdjs.length - 1];
        }
    }
    getAdjBeforeAndAfter(val, params) {
        const res = { before: '', after: '' };
        if (params && params.adj) {
            if (params.adj['BEFORE'] || params.adj['AFTER']) {
                // is an object with BEFORE and AFTER params
                res.before = this.getAdjStringFromList(val, params, params.adj['BEFORE'], params.adj['SEP_BEFORE'], 'BEFORE');
                res.after = this.getAdjStringFromList(val, params, params.adj['AFTER'], params.adj['SEP_AFTER'], 'AFTER');
            }
            else {
                let adj = null; // used when not BEFORE + AFTER combined
                const adjPos = this.getAdjPos(params);
                if (typeof params.adj === 'string' || params.adj instanceof String) {
                    adj = this.getAdjStringFromList(val, params, [params.adj], null, adjPos);
                }
                else if (Array.isArray(params.adj)) {
                    adj = this.getAdjStringFromList(val, params, params.adj, null, adjPos);
                }
                else {
                    const err = new Error();
                    err.name = 'InvalidArgumentError';
                    err.message = 'adj param has an invalid structure';
                    throw err;
                }
                switch (adjPos) {
                    case 'BEFORE': {
                        res.before = adj;
                        break;
                    }
                    case 'AFTER': {
                        res.after = adj;
                        break;
                    }
                }
            }
        }
        return res;
    }
    valueString(val, params) {
        if (this.saveRollbackManager.isEvaluatingEmpty) {
            return 'SOME_STRING';
        }
        // simplest case but edge case
        if (!params) {
            return val;
        }
        if (this.languageImpl.hasCase) {
            params.case = params.case || this.languageImpl.defaultCase;
        }
        // we do not always need genderOwned: only in some situations
        // typically when generating a substantive (plural), we don't need it
        // if we request it anyway, we might end up with an exception when is not in dict
        if (params.det || params.adj || params.possessiveAdj || params.represents) {
            params.genderOwned = this.genderNumberManager.getRefGender(val, params);
        }
        // get the number of the *owneD* thing, not the ownerR
        // 'number': can be null, or S P, or point to an object
        params.numberOwned = this.genderNumberManager.getRefNumber(null, params) || 'S';
        // does all the job for adjectives, before and after
        const adjBeforeAndAfter = this.getAdjBeforeAndAfter(val, params);
        const valSubst = this.languageImpl.getSubstantive(val, params.numberOwned, params.case);
        let possessiveAdj = '';
        if (params.possessiveAdj) {
            possessiveAdj = this.adjectiveManager.getAgreeAdj(params.possessiveAdj, val, params);
        }
        const everythingAfterDet = this.languageImpl.getFormattedNominalGroup(possessiveAdj, adjBeforeAndAfter.before, valSubst, adjBeforeAndAfter.after);
        // we have to generate the det at the end: in Spanish we need to know what follows the det
        let det = '';
        if (params && params.det) {
            const paramsForDet = {
                genderOwned: params.genderOwned,
                numberOwned: params.numberOwned,
                genderOwner: params.genderOwner,
                numberOwner: params.numberOwner,
                case: params.case,
                dist: params.dist,
                after: everythingAfterDet.trim(),
                useTheWhenPlural: params.useTheWhenPlural,
                adjectiveAfterDet: adjBeforeAndAfter.before !== '',
                forceDes: params.FORCE_DES,
            };
            det = this.languageImpl.getDet(params.det, paramsForDet); // can return ''
            // console.log(`${JSON.stringify(paramsForDet)} => ${det}`);
        }
        return det + this.helper.getSeparatingSpace() + everythingAfterDet;
    }
    valueObject(obj, params) {
        //- we already have the next one
        if (this.refsManager.getNextRef(obj)) {
            this.randomManager.setRndNextPos(this.refsManager.getNextRef(obj).rndNextPos);
            this.refsManager.deleteNextRef(obj);
        }
        if (params && params.REPRESENTANT === 'ref') {
            this.valueRef(obj, params);
        }
        else if (params && params.REPRESENTANT === 'refexpr') {
            this.valueRefexpr(obj, params);
        }
        else if (!this.refsManager.hasTriggeredRef(obj)) {
            this.valueRef(obj, params);
        }
        else if (obj.refexpr) {
            this.valueRefexpr(obj, params);
        }
        else {
            //- we trigger ref if obj has no refexpr
            this.valueRef(obj, params);
        }
    }
    valueRefexpr(obj, params) {
        // is only called when obj.refexpr has a value
        obj.refexpr(obj, params);
    }
    valueRef(obj, params) {
        //- printObj('value_ref', obj)
        if (obj.ref) {
            obj.ref(obj, params);
        }
        else {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `${JSON.stringify(obj)} has no ref mixin`;
            throw err;
        }
        this.refsManager.setTriggeredRef(obj);
    }
    valueNumberAsIs(val) {
        return this.helper.protectString(val.toString());
    }
    valueNumberFormat(val, params) {
        return this.helper.protectString(this.languageImpl.getFormatNumberWithNumeral(val, params.FORMAT));
    }
    getGenderFromParams(params) {
        return params.agree != null ? this.genderNumberManager.getRefGender(params.agree, params) : 'M';
    }
    valueNumberTextual(val, params) {
        // only used for some languages
        const gender = this.getGenderFromParams(params);
        return this.languageImpl.getTextualNumber(val, gender);
    }
    valueNumberOrdinalNumber(val, params) {
        // only used for some languages
        const gender = this.getGenderFromParams(params);
        return this.helper.protectString(this.languageImpl.getOrdinalNumber(val, gender));
    }
    valueNumberOrdinalTextual(val, params) {
        if (val % 1 != 0) {
            // is not int
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `ORDINAL_TEXTUAL must be an integer, here ${val}`;
            throw err;
        }
        // currently used only for it_IT, es_ES, fr_FR
        const gender = params.agree != null ? this.genderNumberManager.getRefGender(params.agree, params) : 'M';
        return this.languageImpl.getOrdinal(val, gender);
    }
    valueNumber(val, params) {
        if (this.saveRollbackManager.isEvaluatingEmpty) {
            return 'SOME_NUMBER';
        }
        else {
            if (params) {
                if (params.AS_IS) {
                    return this.valueNumberAsIs(val);
                }
                else if (params.FORMAT) {
                    return this.valueNumberFormat(val, params);
                }
                else if (params.TEXTUAL) {
                    return this.valueNumberTextual(val, params);
                }
                else if (params.ORDINAL_NUMBER) {
                    return this.valueNumberOrdinalNumber(val, params);
                }
                else if (params.ORDINAL_TEXTUAL) {
                    return this.valueNumberOrdinalTextual(val, params);
                }
            }
            return this.helper.protectString(this.languageImpl.getStdFormatedNumber(val));
        }
    }
}
exports.ValueManager = ValueManager;
//# sourceMappingURL=ValueManager.js.map
"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageFrench = void 0;
const LanguageImpl_1 = require("./LanguageImpl");
const french_determiners_1 = require("french-determiners");
const french_adjectives_wrapper_1 = require("french-adjectives-wrapper");
const words_json_1 = __importDefault(require("french-words-gender-lefff/dist/words.json"));
const french_words_1 = require("french-words");
const french_ordinals_1 = require("french-ordinals");
require("numeral/locales/fr");
const locale_1 = require("date-fns/locale");
const french_grammar_js_1 = require("../dist/french-grammar.js");
const lefff_helper_1 = require("lefff-helper");
const french_verbs_1 = require("french-verbs");
const conjugations_json_1 = __importDefault(require("french-verbs-lefff/dist/conjugations.json"));
const n2words_FR_js_1 = __importDefault(require("../../rosaenlg-n2words/dist/n2words_FR.js"));
class LanguageFrench extends LanguageImpl_1.LanguageImpl {
    constructor(languageCommon) {
        super(languageCommon);
        this.iso2 = 'fr';
        this.langForNumeral = 'fr';
        this.langForDateFns = locale_1.fr;
        this.n2wordsLang = 'fr';
        this.n2wordsLib = n2words_FR_js_1.default;
        this.floatingPointWord = 'virgule';
        this.table0to9 = ['zéro', 'un', 'deux', 'trois', 'quatre', 'cinq', 'six', 'sept', 'huit', 'neuf'];
        this.hasGender = true;
        this.hasNeutral = false;
        this.defaultAdjPos = 'AFTER'; // In general, and unlike English, French adjectives are placed after the noun they describe
        this.defaultTense = 'PRESENT';
        this.defaultLastSeparatorForAdjectives = 'et';
        this.universalMapping = {
            UNIVERSAL_PRESENT: 'PRESENT',
            UNIVERSAL_PAST: 'IMPARFAIT',
            UNIVERSAL_FUTURE: 'FUTUR',
            UNIVERSAL_PERFECT: 'PASSE_COMPOSE',
            UNIVERSAL_PLUPERFECT: 'PLUS_QUE_PARFAIT',
        };
        this.spacesWhenSeparatingElements = true;
        try {
            this.dictHelper = new lefff_helper_1.LefffHelper();
        }
        catch (err) {
            // this means that we are in a browser
        }
    }
    getDet(det, params) {
        return french_determiners_1.getDet(det, params.genderOwned, params.numberOwned || 'S', params.numberOwner || 'S', params.adjectiveAfterDet, params.after, params.forceDes);
    }
    getAgreeAdj(adjective, gender, number, subject, params) {
        return french_adjectives_wrapper_1.agreeAdjective(this.getDictManager().getAdjsData(), adjective, gender, number, subject, params && params.adjPos === 'BEFORE', this.getDictManager().getWordData());
    }
    getWordGender(word) {
        return french_words_1.getGender(this.getDictManager().getWordData(), words_json_1.default, word); //NOSONAR
    }
    getOrdinal(val, gender) {
        return french_ordinals_1.getOrdinal(val, gender);
    }
    getTextualNumber(val, gender) {
        if (val === 1) {
            return gender === 'F' ? 'une' : 'un';
        }
        else {
            return super.getTextualNumber(val, gender);
        }
    }
    getOrdinalNumber(val, gender) {
        if (val == 1) {
            if (gender == 'F') {
                return '1re'; // première
            }
            else {
                return '1er';
            }
        }
        else {
            // default implementation works fine for the rest
            return super.getOrdinalNumber(val, gender);
        }
    }
    getSubstantive(subst, number) {
        if (number === 'S') {
            return subst;
        }
        else {
            return french_words_1.getPlural(this.getDictManager().getWordData(), subst);
        }
    }
    parseSimplifiedString(val) {
        return french_grammar_js_1.parse(val, { dictHelper: this.dictHelper });
    }
    thirdPossessionTriggerRef(owner, owned, params, spy) {
        this.valueManager.value(owned, Object.assign({}, params, { det: 'DEFINITE' }));
        spy.appendPugHtml(` de `);
        this.valueManager.value(owner, Object.assign({}, params));
    }
    thirdPossessionRefTriggered(owner, owned, params, spy, genderNumberManager) {
        const det = this.getDet('POSSESSIVE', {
            genderOwned: genderNumberManager.getRefGender(owned, null),
            genderOwner: null,
            numberOwner: genderNumberManager.getRefNumber(owner, params),
            numberOwned: genderNumberManager.getRefNumber(owned, params),
            case: null,
            dist: null,
            after: null,
        });
        spy.appendPugHtml(` ${det} ${owned} `);
    }
    recipientPossession(owned, spy, refsManager, helper) {
        const nextRef = refsManager.getNextRep(owned, { _OWNER: true });
        // vos / votre + value of the object
        spy.appendPugHtml(`${helper.getSorP(['votre', 'vos'], nextRef)} `);
        this.valueManager.value(owned, { _OWNER: true });
    }
    getConjugation(subject, verb, originalTense, number, conjParams, genderNumberManager, embeddedVerbs) {
        const solvedTense = this.solveTense(originalTense);
        let person;
        if (number === 'P') {
            person = 5;
        }
        else {
            person = 2;
        }
        let pronominal;
        if (conjParams && conjParams.pronominal) {
            pronominal = true;
        }
        let aux;
        if (conjParams && conjParams.aux) {
            aux = conjParams.aux;
        }
        let agreeGender;
        let agreeNumber;
        if (conjParams && conjParams.agree) {
            agreeGender = genderNumberManager.getRefGender(conjParams.agree, null);
            agreeNumber = genderNumberManager.getRefNumber(conjParams.agree, null);
        }
        else if (solvedTense === 'PASSE_COMPOSE' || solvedTense === 'PLUS_QUE_PARFAIT') {
            // no explicit "agree" param, but aux is ETRE, either clearly stated or is default,
            // then agreement of the participle must be automatic
            if (aux === 'ETRE' || french_verbs_1.alwaysAuxEtre(verb)) {
                agreeGender = genderNumberManager.getRefGender(subject, null);
                agreeNumber = genderNumberManager.getRefNumber(subject, null);
            }
        }
        return french_verbs_1.getConjugation(embeddedVerbs || conjugations_json_1.default, // give the verbs that we embedded in the compiled template, if there are some; if nothing we use the lefff
        verb, solvedTense, person, {
            aux: aux,
            agreeGender: agreeGender,
            agreeNumber: agreeNumber,
        }, pronominal);
    }
    isPlural(val) {
        /*
          En français, seules les quantités égales ou supérieures à 2 prennent la marque du pluriel.
          Singulier -2 < N < 2
          Pluriel |N| ≥ 2 (N ≤ -2 ou N ≥ 2)
        */
        if (val >= 2 || val <= -2) {
            return true;
        }
        else {
            return false;
        }
    }
}
exports.LanguageFrench = LanguageFrench;
//# sourceMappingURL=LanguageFrench.js.map
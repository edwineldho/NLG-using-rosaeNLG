"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoeckl√©
 * SPDX-License-Identifier: Apache-2.0
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.PossessiveManager = void 0;
class PossessiveManager {
    constructor(languageImpl, genderNumberManager, refsManager, helper) {
        this.languageImpl = languageImpl;
        this.genderNumberManager = genderNumberManager;
        this.refsManager = refsManager;
        this.helper = helper;
    }
    setSpy(spy) {
        this.spy = spy;
    }
    /*
      still very partial
    */
    recipientPossession(owned) {
        this.languageImpl.recipientPossession(owned, this.spy, this.refsManager, this.helper);
    }
    thirdPossession(owner, owned, params) {
        this.helper.insertSeparatingSpaceIfRequired();
        // we need to know if it will be ref or anaphora, but also gender, number...
        const nextRef = this.refsManager.getNextRep(owner, params);
        switch (nextRef.REPRESENTANT) {
            case 'ref': {
                // ref not triggered, thus we will have to do it
                this.languageImpl.thirdPossessionTriggerRef(owner, owned, params, this.spy, this.helper, this.genderNumberManager);
                break;
            }
            case 'refexpr': {
                // ref was already triggered, we only have to manage the possessive
                this.languageImpl.thirdPossessionRefTriggered(owner, owned, params, this.spy, this.genderNumberManager);
                break;
            }
            /* istanbul ignore next */
            default: {
                const err = new Error();
                err.name = '';
                err.message = `internal pb on thirdPossession: ${JSON.stringify(nextRef)}`;
                throw err;
            }
        }
        this.helper.insertSeparatingSpaceIfRequired();
    }
}
exports.PossessiveManager = PossessiveManager;
//# sourceMappingURL=PossessiveManager.js.map
"use strict";
/**
 * @license
 * Copyright 2019 Ludan Stoecklé
 * SPDX-License-Identifier: Apache-2.0
 */
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.LanguageFilterFrench = void 0;
const LanguageFilter_1 = require("./LanguageFilter");
const french_contractions_1 = require("french-contractions");
const titleCaseFrFr = __importStar(require("titlecase-french"));
class LanguageFilterFrench extends LanguageFilter_1.LanguageFilter {
    constructor() {
        super(...arguments);
        this.cleanSpacesPunctuationDoDefault = false;
    }
    getAfterDeterminer(beforeProtect) {
        return `${this.constants.stdBetweenWithParenthesis}(${this.constants.getInBetween(beforeProtect)})([${this.constants.toutesVoyellesMinMaj}hH][${this.constants.tousCaracteresMinMajRe}]*)`;
    }
    // de + voyelle, que + voyelle, etc.
    twoWordsContractions(input) {
        let res = input;
        const contrList = [
            ['de', 'le', 'du'],
            ['de', 'les', 'des'],
            ['de', 'lequel', 'duquel'],
            ['de', 'lesquels', 'desquels'],
            ['de', 'lesquelles', 'desquelles'],
            ['des', 'les', 'des'],
            ['à', 'le', 'au'],
            ['à', 'lequel', 'auquel'],
            ['à', 'les', 'aux'],
            ['à', 'lesquels', 'auxquels'],
            ['à', 'lesquelles', 'auxquelles'],
            ['si', 'il', "s'il"],
            ['si', 'ils', "s'ils"],
        ];
        for (const contr of contrList) {
            res = this.contract2elts(contr[0], contr[1], contr[2], res);
        }
        return res;
    }
    articlesContractionsGeneric(input, beforeProtect) {
        let res = input;
        const contrList = [
            '[Dd]e',
            '[Qq]ue',
            '[Ll]e',
            '[Ll]a',
            '[Ss]e',
            '[Jj]e',
            '[Tt]e',
            '[Mm]e',
            '[Nn]e',
            '[Pp]uisque',
            '[Jj]usque',
            '[Ll]orsque',
        ];
        for (const contr of contrList) {
            // gérer le cas où 'de' est en début de phrase
            const regexDe = new RegExp(`${this.constants.stdBeforeWithParenthesis}(${contr})${this.getAfterDeterminer(beforeProtect)}`, 'g');
            res = res.replace(regexDe, (_match, before, determiner, between, beforeWord, word) => {
                const newBetween = (between + beforeWord).replace(/[\s¤]+/g, ''); // we contract thus keep no space
                if (french_contractions_1.contracts(word, this.dictManager.getAdjsWordsData())) {
                    return `${before}${determiner.substring(0, determiner.length - 1)}'${newBetween}${word}`;
                }
                else {
                    // do nothing
                    return `${before}${newBetween}${determiner} ${word}`;
                }
            });
        }
        return res;
    }
    // ce arbre => cet arbre
    ceCetGeneric(input, beforeProtect) {
        let res = input;
        const regexCe = new RegExp(`${this.constants.stdBeforeWithParenthesis}([Cc]e)${this.getAfterDeterminer(beforeProtect)}`, 'g');
        res = res.replace(regexCe, (_match, before, determiner, between, beforeWord, word) => {
            const newBetween = between + beforeWord;
            if (french_contractions_1.contracts(word, this.dictManager.getAdjsWordsData())) {
                return `${before}${determiner}t${newBetween}${word}`;
            }
            else {
                // do nothing
                return `${before}${determiner}${newBetween}${word}`;
            }
        });
        return res;
    }
    contractions(input) {
        let res = input;
        res = this.ceCetGeneric(res, false);
        res = this.articlesContractionsGeneric(res, false);
        res = this.twoWordsContractions(res);
        return res;
    }
    titlecase(input) {
        return titleCaseFrFr.convert(input);
    }
    cleanSpacesPunctuation(input) {
        let res = input;
        // all but . and ,
        const regexAllButDot = new RegExp(`(${this.constants.spaceOrNonBlockingClass}*)([:!\\?;])(${this.constants.spaceOrNonBlockingClass}*)`, 'g');
        res = res.replace(regexAllButDot, function (_match, before, punc, after) {
            return `${before.replace(/\s/g, '')}\xa0${punc} ${after.replace(/\s/g, '')}`;
        });
        // . and , and …
        const regexDot = new RegExp(`(${this.constants.spaceOrNonBlockingClass}*)([\\.,…])(${this.constants.spaceOrNonBlockingClass}*)`, 'g');
        res = res.replace(regexDot, function (_match, before, punc, after) {
            return `${before.replace(/\s/g, '')}${punc} ${after.replace(/\s/g, '')}`;
        });
        return res;
    }
}
exports.LanguageFilterFrench = LanguageFilterFrench;
//# sourceMappingURL=LanguageFilterFrench.js.map
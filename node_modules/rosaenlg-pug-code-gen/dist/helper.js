"use strict";
/**
 * @license
 * Copyright 2018, Ludan StoecklÃ©
 * SPDX-License-Identifier: MIT
 */
Object.defineProperty(exports, "__esModule", { value: true });
exports.CodeGenHelper = void 0;
const languageCodeGenHelper_1 = require("./languageCodeGenHelper");
const recast_1 = require("recast");
function keyEqualsTo(prop, val) {
    // when 'val':, is in value, when val:, is in name
    return prop.key.value === val || prop.key.name === val;
}
class CodeGenHelper {
    constructor(language, embedResources) {
        this.verbCandidates = [];
        this.wordCandidates = [];
        this.adjectiveCandidates = [];
        this.embedResources = embedResources;
        this.languageCodeGen = languageCodeGenHelper_1.buildLanguageCodeGen(languageCodeGenHelper_1.getIso2fromLocale(language));
        this.iso2 = this.languageCodeGen.iso2;
    }
    // public for test purposes
    getVerbCandidates() {
        return this.verbCandidates;
    }
    getWordCandidates() {
        return this.wordCandidates;
    }
    getAdjectiveCandidates() {
        return this.adjectiveCandidates;
    }
    getAllLinguisticResources(linguisticResourcesToSolve) {
        // 1. init
        const allLinguisticResources = {
            verbs: {},
            words: {},
            adjectives: {},
        };
        // 2. get explicit resources, already solved
        if (linguisticResourcesToSolve && linguisticResourcesToSolve.verbs) {
            allLinguisticResources.verbs = this.languageCodeGen.getVerbsInfo(linguisticResourcesToSolve.verbs);
        }
        if (linguisticResourcesToSolve && linguisticResourcesToSolve.words) {
            allLinguisticResources.words = this.languageCodeGen.getWordsInfo(linguisticResourcesToSolve.words);
        }
        if (linguisticResourcesToSolve && linguisticResourcesToSolve.adjectives) {
            allLinguisticResources.adjectives = this.languageCodeGen.getAdjectivesInfo(linguisticResourcesToSolve.adjectives);
        }
        // 3. add found candidates
        // console.log(verbCandidates);
        allLinguisticResources.verbs = Object.assign(Object.assign({}, this.getVerbCandidatesData()), allLinguisticResources.verbs);
        allLinguisticResources.words = Object.assign(Object.assign({}, this.getWordCandidatesData()), allLinguisticResources.words);
        allLinguisticResources.adjectives = Object.assign(Object.assign({}, this.getAdjectiveCandidatesData()), allLinguisticResources.adjectives);
        return allLinguisticResources;
    }
    getVerbCandidatesData() {
        const res = {};
        if (this.languageCodeGen.hasFlexVerbs) {
            for (const verbCandidate of this.verbCandidates) {
                try {
                    const verbInfo = this.languageCodeGen.getVerbInfo(verbCandidate);
                    if (!verbInfo)
                        throw new Error();
                    res[verbCandidate] = verbInfo;
                }
                catch (e) {
                    console.log(`Could not find any data for ${this.iso2} verb candidate ${verbCandidate}`);
                }
            }
        }
        return res;
    }
    getWordCandidatesData() {
        const res = {};
        if (this.languageCodeGen.hasFlexWords) {
            for (const wordCandidate of this.wordCandidates) {
                try {
                    const wordInfo = this.languageCodeGen.getWordInfo(wordCandidate);
                    /* istanbul ignore next */
                    if (!wordInfo)
                        throw new Error();
                    // in English we have more than just the irregular ones, but it's not a problem
                    res[wordCandidate] = this.languageCodeGen.getWordInfo(wordCandidate);
                }
                catch (e) {
                    console.log(`Could not find any data for ${this.iso2} word candidate ${wordCandidate}`);
                }
            }
        }
        return res;
    }
    getAdjectiveCandidatesData() {
        const res = {};
        if (this.languageCodeGen.hasFlexAdjectives) {
            for (const adjectiveCandidate of this.adjectiveCandidates) {
                try {
                    const adjectiveInfo = this.languageCodeGen.getAdjectiveInfo(adjectiveCandidate);
                    /* istanbul ignore next */
                    if (!adjectiveInfo)
                        throw new Error();
                    res[adjectiveCandidate] = adjectiveInfo;
                }
                catch (e) {
                    console.log(`Could not find any data for ${this.iso2} adjective candidate ${adjectiveCandidate}`);
                }
            }
        }
        return res;
    }
    extractHelper(args, extractor, store) {
        const candidate = extractor.apply(this, [args]);
        if (typeof candidate === 'string') {
            store.push(candidate);
        } /* istanbul ignore next */
        else if (Array.isArray(candidate)) {
            // string[]
            store.push(...candidate);
        }
    }
    extractVerbCandidate(args) {
        this.extractHelper(args, this.getVerbCandidate, this.verbCandidates);
    }
    getVerbCandidate(args) {
        if (!this.embedResources || !this.languageCodeGen.hasFlexVerbs) {
            return;
        }
        const parsedExpr = this.getParsedExpr(args);
        this.checkAtLeastParams(parsedExpr, 2);
        const secondArg = parsedExpr[1];
        const isLitteralOrArray = (elt) => elt.type === 'Literal' || elt.type === 'ArrayExpression';
        let found;
        if (isLitteralOrArray(secondArg)) {
            // string second arg form, or an array
            found = secondArg;
        }
        else {
            // "verb:"" form
            recast_1.visit(secondArg, {
                visitProperty: function (path) {
                    if (keyEqualsTo(path.value, 'verb')) {
                        if (isLitteralOrArray(path.value.value)) {
                            found = path.value.value;
                            this.abort();
                        }
                    }
                    this.traverse(path);
                },
            });
        }
        return this.getEltsFromEltOrListArg(found);
    }
    extractWordCandidateFromVerbalForm(args) {
        this.extractHelper(args, this.getWordCandidateFromVerbalForm, this.wordCandidates);
    }
    getWordCandidateFromVerbalForm(args) {
        if (!this.embedResources || !this.languageCodeGen.hasFlexWords) {
            return;
        }
        const parsedExpr = this.getParsedExpr(args);
        this.checkAtLeastParams(parsedExpr, 1);
        return this.getEltsFromEltOrListArg(parsedExpr[0]);
    }
    extractWordCandidateFromSetRefGender(args) {
        this.extractHelper(args, this.getWordCandidateFromSetRefGender, this.wordCandidates);
    }
    getWordCandidateFromSetRefGender(args) {
        if (!this.embedResources || !this.languageCodeGen.hasFlexWords) {
            return;
        }
        const parsedExpr = this.getParsedExpr(args);
        this.checkAtLeastParams(parsedExpr, 2);
        const val = this.getStringFromArg(parsedExpr[1]);
        if (val != null && val !== 'M' && val !== 'F' && val !== 'N') {
            return val;
        }
    }
    getEltsFromEltOrListArg(arg) {
        const res = [];
        if (!arg) {
            return [];
        }
        const isStringLiteral = (elt) => elt.type === 'Literal' && typeof elt.value === 'string';
        if (isStringLiteral(arg)) {
            // one single adj
            res.push(arg.value);
        }
        else if (arg.type == 'ArrayExpression') {
            for (const elt of arg.elements) {
                if (isStringLiteral(elt)) {
                    res.push(elt.value);
                }
            }
        }
        return res;
    }
    extractAdjCandidateFromSubjectVerbAdj(args) {
        this.extractHelper(args, this.getAdjCandidateFromSubjectVerbAdj, this.adjectiveCandidates);
    }
    getAdjCandidateFromSubjectVerbAdj(args) {
        if (!this.embedResources || !this.languageCodeGen.hasFlexAdjectives) {
            return;
        }
        const parsedExpr = this.getParsedExpr(args);
        // there are always 3 args (S + V + A), sometimes 4 when extra params
        this.checkAtLeastParams(parsedExpr, 3);
        return this.getEltsFromEltOrListArg(parsedExpr[2]);
    }
    extractAdjectiveCandidateFromAgreeAdj(args) {
        this.extractHelper(args, this.getAdjectiveCandidateFromAgreeAdj, this.adjectiveCandidates);
    }
    getAdjectiveCandidateFromAgreeAdj(args) {
        if (!this.embedResources || !this.languageCodeGen.hasFlexAdjectives) {
            return;
        }
        const parsedExpr = this.getParsedExpr(args);
        // there are always 2 args
        this.checkAtLeastParams(parsedExpr, 2);
        return this.getEltsFromEltOrListArg(parsedExpr[0]);
    }
    extractAdjectiveCandidateFromValue(args) {
        this.extractHelper(args, this.getAdjectiveCandidatesFromValue, this.adjectiveCandidates);
    }
    getAdjectiveCandidatesFromValue(args) {
        if (!this.embedResources || !this.languageCodeGen.hasFlexAdjectives) {
            return [];
        }
        const res = [];
        const parsedExpr = this.getParsedExpr(args);
        // form with 1 element is acceptable: we should not throw an exception
        this.checkAtLeastParams(parsedExpr, 1);
        // but we are only interested in the other arguments
        if (parsedExpr.length > 1) {
            const secondArg = parsedExpr[1];
            function addArrayToRes(elts) {
                for (const elt of elts) {
                    if (elt.type === 'Literal') {
                        res.push(elt.value);
                    }
                }
            }
            recast_1.visit(secondArg, {
                visitProperty: function (path) {
                    if (keyEqualsTo(path.value, 'adj')) {
                        const pvv = path.value.value;
                        switch (pvv.type) {
                            case 'Literal': {
                                res.push(pvv.value);
                                break;
                            }
                            case 'ArrayExpression': {
                                addArrayToRes(pvv.elements);
                                break;
                            }
                            case 'ObjectExpression': {
                                const props = pvv.properties;
                                for (const prop of props) {
                                    if (keyEqualsTo(prop, 'BEFORE') || keyEqualsTo(prop, 'AFTER')) {
                                        addArrayToRes(prop.value.elements);
                                    }
                                }
                                break;
                            }
                        }
                    }
                    else if (keyEqualsTo(path.value, 'possessiveAdj')) {
                        // Italian possessiveAdj:
                        if (path.value.value.type === 'Literal') {
                            res.push(path.value.value.value);
                        }
                    }
                    this.traverse(path);
                },
            });
        }
        return res;
    }
    extractWordCandidateFromThirdPossession(args) {
        this.extractHelper(args, this.getWordCandidateFromThirdPossession, this.wordCandidates);
    }
    getWordCandidateFromThirdPossession(args) {
        if (!this.embedResources || !this.languageCodeGen.hasFlexWords) {
            return;
        }
        const res = [];
        // #[+thirdPossession(XXX, 'couleur')]
        // there can be 2 words
        const parsedExpr = this.getParsedExpr(args);
        // there must be 2 parameters
        this.checkAtLeastParams(parsedExpr, 2);
        for (let i = 0; i <= 1; i++) {
            const str = this.getStringFromArg(parsedExpr[i]);
            if (str) {
                res.push(str);
            }
        }
        return res;
    }
    checkAtLeastParams(parsedExpr, atLeast) {
        if (!parsedExpr) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `parsed expression is null`;
            throw err;
        }
        else if (parsedExpr.length < atLeast) {
            const err = new Error();
            err.name = 'InvalidArgumentError';
            err.message = `has ${parsedExpr.length} parameters while should have at least ${atLeast}`;
            throw err;
        }
    }
    getParsedExpr(args) {
        if (!args) {
            return null;
        }
        const parsed = recast_1.parse(args);
        // looks like it always has this structure
        const expression = parsed.program.body[0].expression;
        if (expression.expressions) {
            return expression.expressions;
        }
        else {
            // when there is only 1 argument, like some value cases
            // we just put in an array to look like the others
            // console.log(parsed.program.body[0].expression);
            return [expression];
        }
    }
    getStringFromArg(arg) {
        if (arg.type === 'Literal' && typeof arg.value === 'string') {
            // string second arg form
            return arg.value;
        }
        return null;
    }
    extractWordCandidateFromValue(args) {
        this.extractHelper(args, this.getWordCandidateFromValue, this.wordCandidates);
    }
    getWordCandidateFromValue(args) {
        // en_US to get the plurals
        if (!this.embedResources || !this.languageCodeGen.hasFlexWords) {
            return;
        }
        /*
        no: it is also useful when adj is here, to make the agreement!
        if (args.indexOf('represents') === -1) {
          return null;
        }
        */
        const parsed = recast_1.parse(args);
        const parsedExpr = parsed.program.body[0].expression;
        let firstArg;
        if (parsedExpr.expressions && parsedExpr.expressions.length >= 1) {
            // multiple args
            firstArg = parsedExpr.expressions[0];
        }
        else {
            // single argument
            firstArg = parsedExpr;
        }
        return this.getEltsFromEltOrListArg(firstArg);
    }
}
exports.CodeGenHelper = CodeGenHelper;
//# sourceMappingURL=helper.js.map